name: CD Pipeline - Azure Blue-Green Deployment

on:
  push:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      deploy-environment:
        description: 'Environment to deploy'
        required: true
        default: 'qa'
        type: choice
        options:
          - qa
          - production

env:
  AZURE_RESOURCE_GROUP: 'bp-calculator-rg'
  AZURE_LOCATION: 'eastus'
  CONTAINER_APP_ENVIRONMENT: 'bp-calculator-env'
  CONTAINER_APP_NAME: 'bp-calculator-app'
  FRONT_DOOR_NAME: 'bp-calculator-fd'
  ACR_NAME: 'bpcalculatoracr'

permissions:
  id-token: write
  contents: read

jobs:
  # =====================
  # CI PHASE (Build & Test)
  # =====================
  continuous-integration:
    runs-on: ubuntu-latest
    outputs:
      docker-tag: ${{ steps.version.outputs.docker-tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Generate Docker tag
        id: version
        run: |
          SHORT_SHA=${GITHUB_SHA::8}
          TAG="build-$(date +%Y%m%d)-${SHORT_SHA}"
          echo "docker-tag=$TAG" >> $GITHUB_OUTPUT
          echo "TAG=$TAG" >> $GITHUB_ENV
          echo "Using tag: $TAG"
      - name: Restore dependencies
        run: dotnet restore ./bp-calculator.sln

      - name: Build solution
        run: dotnet build ./bp-calculator.sln --configuration Release --no-restore

      - name: Run tests
        run: dotnet test ./BP.Tests/BP.Tests.csproj --configuration Release --no-build --verbosity normal

      - name: Login to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ env.ACR_NAME }}.azurecr.io
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Build and push Docker image
        run: |
          TAG="${{ env.TAG }}"
          FULL_IMAGE_NAME="${{ env.ACR_NAME }}.azurecr.io/bp-calculator:$TAG"
          
          echo "Building image: $FULL_IMAGE_NAME"
          docker build -t $FULL_IMAGE_NAME .
          
          echo "Pushing image to ACR..."
          docker push $FULL_IMAGE_NAME
          
          # Also tag as latest
          LATEST_IMAGE="${{ env.ACR_NAME }}.azurecr.io/bp-calculator:latest"
          docker tag $FULL_IMAGE_NAME $LATEST_IMAGE
          docker push $LATEST_IMAGE
          
          echo "Image successfully pushed: $FULL_IMAGE_NAME"
          echo "Latest tag also updated: $LATEST_IMAGE"
  # =====================
  # PERFORMANCE & SECURITY TESTING
  # =====================
  performance-and-penetration-testing:
    runs-on: ubuntu-latest
    needs: continuous-integration
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ env.ACR_NAME }}.azurecr.io
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Pull and run test container
        run: |
          # Get the tag from the previous job
          TAG="${{ needs.continuous-integration.outputs.docker-tag }}"
          FULL_IMAGE_NAME="${{ env.ACR_NAME }}.azurecr.io/bp-calculator:$TAG"
          
          echo "Pulling image: $FULL_IMAGE_NAME"
          echo "Tag from CI job: $TAG"
          
          if [ -z "$TAG" ]; then
            echo "ERROR: TAG is empty! Check continuous-integration job output."
            exit 1
          fi
          
          docker pull $FULL_IMAGE_NAME
          docker run -d --name bp-test -p 8080:8080 $FULL_IMAGE_NAME
          
          echo "Waiting for application to be healthy..."
          for i in {1..12}; do
            if curl -s -f http://localhost:8080/health > /dev/null; then
              echo "Application is healthy!"
              break
            fi
            echo "Waiting for application... Attempt $i/12"
            sleep 5
          done
      - name: Install k6 for performance testing
        run: |
          sudo apt-get update
          sudo apt-get install -y ca-certificates gnupg
          sudo mkdir -p /etc/apt/keyrings
          curl -fsSL https://dl.k6.io/key.gpg | sudo gpg --dearmor -o /etc/apt/keyrings/k6.gpg
          echo "deb [signed-by=/etc/apt/keyrings/k6.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install -y k6
      - name: Run Health Check Performance Test
        run: |
          echo "Starting Health Check Performance Test..."
          k6 run ./PerformanceTests/health-check-test.js
      - name: Install security tools
        run: |
          sudo apt-get update
          sudo apt-get install -y nmap curl
      - name: Security Tests
        run: |
          echo "Running security tests..."
          nmap -sV -sC localhost -p 8080
          curl -I http://localhost:8080/health
          
          curl -X POST http://localhost:8080/api/bp/calculate \
            -H "Content-Type: application/json" \
            -d '{"Systolic": "120 OR 1=1", "Diastolic": 80}' || echo "SQL injection test passed"
          
          curl -X POST http://localhost:8080/api/bmi/calculate \
            -H "Content-Type: application/json" \
            -d '{"Weight": "70 UNION SELECT", "Height": 1.75}' || echo "SQL injection test passed"
      - name: Cleanup test container
        run: |
          docker stop bp-test || true
          docker rm bp-test || true
  # =====================
  # QA DEPLOYMENT (Single Environment)
  # =====================
  deploy-qa:
    runs-on: ubuntu-latest
    needs: [continuous-integration, performance-and-penetration-testing]
    environment: qa
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy to QA Container App
        run: |
          TAG="${{ needs.continuous-integration.outputs.docker-tag }}"
          FULL_IMAGE_NAME="${{ env.ACR_NAME }}.azurecr.io/bp-calculator:$TAG"
          
          echo "Deploying image: $FULL_IMAGE_NAME to QA"
          
          # Create or update QA Container App (environment should already exist)
          az containerapp create \
            --name "${{ env.CONTAINER_APP_NAME }}-qa" \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --image "$FULL_IMAGE_NAME" \
            --environment "${{ env.CONTAINER_APP_ENVIRONMENT }}-qa" \
            --target-port 8080 \
            --ingress external \
            --cpu 0.5 \
            --memory 1.0Gi \
            --min-replicas 1 \
            --max-replicas 3 \
            --env-vars ASPNETCORE_ENVIRONMENT=QA
      - name: Verify QA deployment
        run: |
          FQDN=$(az containerapp show \
            --name "${{ env.CONTAINER_APP_NAME }}-qa" \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --query "configuration.ingress.fqdn" \
            --output tsv)
          
          echo "QA Application URL: https://$FQDN"
          
          sleep 30
          curl -f "https://$FQDN/health" || (echo "QA deployment health check failed" && exit 1)
  # =====================
  # PRODUCTION BLUE-GREEN DEPLOYMENT
  # =====================
  deploy-production-blue-green:
    runs-on: ubuntu-latest
    needs: [continuous-integration, deploy-qa]
    environment: production
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Determine active environment
        id: detect-env
        run: |
          # Check which backend pool is currently active in Front Door
          CURRENT_BACKEND=$(az network front-door routing-rule show \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --front-door-name "${{ env.FRONT_DOOR_NAME }}" \
            --name "bp-routing-rule" \
            --query "backendPools[0].name" \
            --output tsv 2>/dev/null || echo "blue-pool")
          
          if [[ "$CURRENT_BACKEND" == "blue-pool" ]]; then
            echo "CURRENT_ENV=blue" >> $GITHUB_OUTPUT
            echo "NEW_ENV=green" >> $GITHUB_OUTPUT
            echo "CURRENT_BACKEND=blue-pool" >> $GITHUB_OUTPUT
            echo "NEW_BACKEND=green-pool" >> $GITHUB_OUTPUT
            echo "Currently active: BLUE, will deploy to GREEN"
          else
            echo "CURRENT_ENV=green" >> $GITHUB_OUTPUT
            echo "NEW_ENV=blue" >> $GITHUB_OUTPUT
            echo "CURRENT_BACKEND=green-pool" >> $GITHUB_OUTPUT
            echo "NEW_BACKEND=blue-pool" >> $GITHUB_OUTPUT
            echo "Currently active: GREEN, will deploy to BLUE"
          fi
      - name: Deploy to inactive environment
        run: |
          TAG="${{ needs.continuous-integration.outputs.docker-tag }}"
          FULL_IMAGE_NAME="${{ env.ACR_NAME }}.azurecr.io/bp-calculator:$TAG"
          
          echo "Deploying image: $FULL_IMAGE_NAME to ${{ steps.detect-env.outputs.NEW_ENV }} environment"
          
          # Create or update the inactive environment (production environment should already exist)
          az containerapp create \
            --name "${{ env.CONTAINER_APP_NAME }}-${{ steps.detect-env.outputs.NEW_ENV }}" \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --image "$FULL_IMAGE_NAME" \
            --environment "${{ env.CONTAINER_APP_ENVIRONMENT }}-prod" \
            --target-port 8080 \
            --ingress external \
            --cpu 1.0 \
            --memory 2.0Gi \
            --min-replicas 2 \
            --max-replicas 5 \
            --env-vars ASPNETCORE_ENVIRONMENT=Production
      - name: Test new deployment
        run: |
          # Get the FQDN of the new deployment
          NEW_FQDN=$(az containerapp show \
            --name "${{ env.CONTAINER_APP_NAME }}-${{ steps.detect-env.outputs.NEW_ENV }}" \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --query "configuration.ingress.fqdn" \
            --output tsv)
          
          echo "Testing new deployment at: https://$NEW_FQDN"
          
          # Wait for deployment to be ready
          sleep 30
          
          # Run validation tests against the new deployment
          for i in {1..10}; do
            if curl -f "https://$NEW_FQDN/health"; then
              echo "New deployment is healthy!"
              
              # Run smoke tests
              echo "Running smoke tests..."
              curl -X POST "https://$NEW_FQDN/api/bp/calculate" \
                -H "Content-Type: application/json" \
                -d '{"Systolic": 120, "Diastolic": 80}'
              
              curl -X POST "https://$NEW_FQDN/api/bmi/calculate" \
                -H "Content-Type: application/json" \
                -d '{"Weight": 70, "Height": 1.75}'
              
              echo "Smoke tests passed!"
              break
            fi
            echo "Waiting for new deployment... Attempt $i/10"
            sleep 10
          done
      - name: Switch traffic in Azure Front Door
        run: |
          # Update Front Door to route 100% traffic to the new environment
          az network front-door routing-rule update \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --front-door-name "${{ env.FRONT_DOOR_NAME }}" \
            --name "bp-routing-rule" \
            --backend-pool "${{ steps.detect-env.outputs.NEW_BACKEND }}"
          
          echo "Traffic switched to ${{ steps.detect-env.outputs.NEW_ENV }} environment"
      - name: Verify traffic switch
        run: |
          # Get Front Door endpoint
          FD_ENDPOINT=$(az network front-door frontend-endpoint list \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --front-door-name "${{ env.FRONT_DOOR_NAME }}" \
            --query "[0].hostName" \
            --output tsv)
          
          echo "Front Door URL: https://$FD_ENDPOINT"
          
          # Verify traffic is flowing through Front Door
          sleep 10
          curl -f "https://$FD_ENDPOINT/health" || (echo "Front Door health check failed" && exit 1)
          echo "Traffic successfully routed through Front Door"
      - name: Clean up old environment
        run: |
          # Optionally, update the old environment with the new image for next deployment
          echo "Updating old environment (${{ steps.detect-env.outputs.CURRENT_ENV }}) for next deployment..."
          TAG="${{ needs.continuous-integration.outputs.docker-tag }}"
          FULL_IMAGE_NAME="${{ env.ACR_NAME }}.azurecr.io/bp-calculator:$TAG"
          
          az containerapp update \
            --name "${{ env.CONTAINER_APP_NAME }}-${{ steps.detect-env.outputs.CURRENT_ENV }}" \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --image "$FULL_IMAGE_NAME" \
            --cpu 1.0 \
            --memory 2.0Gi \
            --min-replicas 1 \
            --max-replicas 2
          
          echo "Old environment updated and ready for next deployment cycle"
