name: CD Pipeline - Azure Blue-Green Deployment

on:
  push:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      deploy-environment:
        description: 'Environment to deploy'
        required: true
        default: 'qa'
        type: choice
        options:
          - qa
          - production

env:
  AZURE_RESOURCE_GROUP: 'bp-calculator-rg'
  AZURE_LOCATION: 'eastus'
  CONTAINER_APP_ENVIRONMENT: 'bp-calculator-env-qa'
  CONTAINER_APP_NAME: 'bp-calculator-app'
  FRONT_DOOR_NAME: 'bp-calculator-fd'
  ACR_NAME: 'bpcalculatoracr'

permissions:
  id-token: write
  contents: read

jobs:
  # =====================
  # CI PHASE (Build & Test)
  # =====================
  continuous-integration:
    runs-on: ubuntu-latest
    outputs:
      docker-tag: ${{ steps.version.outputs.docker-tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Generate Docker tag
        id: version
        run: |
          SHORT_SHA=${GITHUB_SHA::8}
          TAG="build-$(date +%Y%m%d)-${SHORT_SHA}"
          echo "docker-tag=$TAG" >> $GITHUB_OUTPUT
          echo "TAG=$TAG" >> $GITHUB_ENV
          echo "Using tag: $TAG"
          
      - name: Restore dependencies
        run: dotnet restore ./bp-calculator.sln

      - name: Build solution
        run: dotnet build ./bp-calculator.sln --configuration Release --no-restore

      - name: Run tests
        run: dotnet test ./BP.Tests/BP.Tests.csproj --configuration Release --no-build --verbosity normal

      - name: Login to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ env.ACR_NAME }}.azurecr.io
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Build and push Docker image
        run: |
          TAG="${{ env.TAG }}"
          FULL_IMAGE_NAME="${{ env.ACR_NAME }}.azurecr.io/bp-calculator:$TAG"
          
          echo "Building image: $FULL_IMAGE_NAME"
          docker build -t $FULL_IMAGE_NAME .
          
          echo "Pushing image to ACR..."
          docker push $FULL_IMAGE_NAME
          
          # Also tag as latest
          LATEST_IMAGE="${{ env.ACR_NAME }}.azurecr.io/bp-calculator:latest"
          docker tag $FULL_IMAGE_NAME $LATEST_IMAGE
          docker push $LATEST_IMAGE
          
          echo "Image successfully pushed: $FULL_IMAGE_NAME"
          echo "Latest tag also updated: $LATEST_IMAGE"

  # =====================
  # PERFORMANCE & SECURITY TESTING
  # =====================
  performance-and-penetration-testing:
    runs-on: ubuntu-latest
    needs: continuous-integration
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ env.ACR_NAME }}.azurecr.io
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Pull and run test container
        run: |
          # Get the tag from the previous job
          TAG="${{ needs.continuous-integration.outputs.docker-tag }}"
          FULL_IMAGE_NAME="${{ env.ACR_NAME }}.azurecr.io/bp-calculator:$TAG"
          
          echo "Pulling image: $FULL_IMAGE_NAME"
          echo "Tag from CI job: $TAG"
          
          if [ -z "$TAG" ]; then
            echo "ERROR: TAG is empty! Check continuous-integration job output."
            exit 1
          fi
          
          docker pull $FULL_IMAGE_NAME
          docker run -d --name bp-test -p 8080:8080 $FULL_IMAGE_NAME
          
          echo "Waiting for application to be healthy..."
          for i in {1..12}; do
            if curl -s -f http://localhost:8080/health > /dev/null; then
              echo "Application is healthy!"
              break
            fi
            echo "Waiting for application... Attempt $i/12"
            sleep 5
          done
            
      - name: Install k6 for performance testing
        run: |
          sudo apt-get update
          sudo apt-get install -y ca-certificates gnupg
          sudo mkdir -p /etc/apt/keyrings
          curl -fsSL https://dl.k6.io/key.gpg | sudo gpg --dearmor -o /etc/apt/keyrings/k6.gpg
          echo "deb [signed-by=/etc/apt/keyrings/k6.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install -y k6
          
      - name: Run Health Check Performance Test
        run: |
          echo "Starting Health Check Performance Test..."
          k6 run ./PerformanceTests/health-check-test.js
          
      - name: Install security tools
        run: |
          sudo apt-get update
          sudo apt-get install -y nmap curl
          
      - name: Security Tests
        run: |
          echo "Running security tests..."
          nmap -sV -sC localhost -p 8080
          curl -I http://localhost:8080/health
          
          curl -X POST http://localhost:8080/api/bp/calculate \
            -H "Content-Type: application/json" \
            -d '{"Systolic": "120 OR 1=1", "Diastolic": 80}' || echo "SQL injection test passed"
          
          curl -X POST http://localhost:8080/api/bmi/calculate \
            -H "Content-Type: application/json" \
            -d '{"Weight": "70 UNION SELECT", "Height": 1.75}' || echo "SQL injection test passed"
            
      - name: Cleanup test container
        run: |
          docker stop bp-test || true
          docker rm bp-test || true

  # =====================
  # QA DEPLOYMENT (Single Environment)
  # =====================
  deploy-qa:
    runs-on: ubuntu-latest
    needs: [continuous-integration, performance-and-penetration-testing]
    environment: qa
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy to QA Container App
        run: |
          TAG="${{ needs.continuous-integration.outputs.docker-tag }}"
          FULL_IMAGE_NAME="${{ env.ACR_NAME }}.azurecr.io/bp-calculator:$TAG"
          
          echo "Deploying image: $FULL_IMAGE_NAME to QA"
          
          # Check if Container App already exists
          if az containerapp show --name "${{ env.CONTAINER_APP_NAME }}-qa" --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" --query "name" -o tsv 2>/dev/null; then
            echo "Updating existing QA Container App..."
            az containerapp update \
              --name "${{ env.CONTAINER_APP_NAME }}-qa" \
              --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
              --image "$FULL_IMAGE_NAME" \
              --set-env-vars ASPNETCORE_ENVIRONMENT=QA
          else
            echo "Creating new QA Container App..."
            az containerapp create \
              --name "${{ env.CONTAINER_APP_NAME }}-qa" \
              --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
              --image "$FULL_IMAGE_NAME" \
              --environment "${{ env.CONTAINER_APP_ENVIRONMENT }}" \
              --target-port 8080 \
              --ingress external \
              --cpu 0.5 \
              --memory 1.0Gi \
              --min-replicas 1 \
              --max-replicas 3 \
              --env-vars ASPNETCORE_ENVIRONMENT=QA
          fi

      - name: Fast QA verification
        run: |
          echo "Starting fast verification (2-3 minute timeout)..."
          start_time=$(date +%s)
          max_time=180  # 3 minutes max
          
          # 1. Wait for Container App to exist (30 seconds max)
          echo "Waiting for Container App to be created..."
          for i in {1..6}; do
            if az containerapp show --name "${{ env.CONTAINER_APP_NAME }}-qa" --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" --query "name" -o tsv 2>/dev/null; then
              echo "Container App created"
              break
            fi
            if [[ $i -eq 6 ]]; then
              echo "Container App not created after 30 seconds"
              exit 1
            fi
            sleep 5
          done
          
          # 2. Wait for FQDN (60 seconds max)
          echo "Waiting for public URL..."
          FQDN=""
          for i in {1..12}; do
            FQDN=$(az containerapp show \
              --name "${{ env.CONTAINER_APP_NAME }}-qa" \
              --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
              --query "properties.configuration.ingress.fqdn" \
              --output tsv 2>/dev/null || echo "")
            
            if [[ -n "$FQDN" && "$FQDN" != "null" ]]; then
              echo "Got URL: $FQDN"
              break
            fi
            
            if [[ $i -eq 12 ]]; then
              echo "No public URL after 60 seconds (ingress might be internal)"
              # Don't fail - some apps use internal ingress
            else
              echo "Waiting for URL... ($i/12)"
              sleep 5
            fi
          done
          
          # 3. Quick health check if we have URL (60 seconds max)
          if [[ -n "$FQDN" && "$FQDN" != "null" ]]; then
            echo "Testing health endpoint (quick check)..."
            HEALTH_PASSED=false
            
            for i in {1..12}; do
              current_time=$(date +%s)
              elapsed=$((current_time - start_time))
              
              if [[ $elapsed -ge $max_time ]]; then
                echo "Timeout reached (3 minutes). Skipping further checks."
                break
              fi
              
              # Quick 5-second timeout curl
              if timeout 5 curl -s -f "https://$FQDN/health" > /dev/null 2>&1; then
                echo "Health check passed!"
                HEALTH_PASSED=true
                break
              fi
              
              if [[ $i -lt 12 ]]; then
                echo "Health check attempt $i/12 failed, retrying..."
                sleep 5
              fi
            done
            
            if [[ "$HEALTH_PASSED" == false ]]; then
              echo "Health check didn't pass, but deployment succeeded"
              echo "App might be starting up. Check manually later."
            fi
          fi
          
          elapsed=$(( $(date +%s) - start_time ))
          echo "QA verification completed in ${elapsed} seconds"

  # =====================
  # PRODUCTION BLUE-GREEN DEPLOYMENT
  # =====================
  deploy-production-blue-green:
    runs-on: ubuntu-latest
    needs: [continuous-integration, deploy-qa]
    environment: production
    steps:
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Determine active environment
        id: detect-env
        run: |
          # Check which backend pool is currently active in Front Door
          CURRENT_BACKEND=$(az network front-door routing-rule show \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --front-door-name "${{ env.FRONT_DOOR_NAME }}" \
            --name "bp-routing-rule" \
            --query "backendPools[0].name" \
            --output tsv 2>/dev/null || echo "blue-pool")
          
          if [[ "$CURRENT_BACKEND" == "blue-pool" ]]; then
            echo "CURRENT_ENV=blue" >> $GITHUB_OUTPUT
            echo "NEW_ENV=green" >> $GITHUB_OUTPUT
            echo "CURRENT_BACKEND=blue-pool" >> $GITHUB_OUTPUT
            echo "NEW_BACKEND=green-pool" >> $GITHUB_OUTPUT
            echo "Currently active: BLUE, will deploy to GREEN"
          else
            echo "CURRENT_ENV=green" >> $GITHUB_OUTPUT
            echo "NEW_ENV=blue" >> $GITHUB_OUTPUT
            echo "CURRENT_BACKEND=green-pool" >> $GITHUB_OUTPUT
            echo "NEW_BACKEND=blue-pool" >> $GITHUB_OUTPUT
            echo "Currently active: GREEN, will deploy to BLUE"
          fi

      - name: Deploy to inactive environment
        run: |
          TAG="${{ needs.continuous-integration.outputs.docker-tag }}"
          FULL_IMAGE_NAME="${{ env.ACR_NAME }}.azurecr.io/bp-calculator:$TAG"
          
          echo "Deploying image: $FULL_IMAGE_NAME to ${{ steps.detect-env.outputs.NEW_ENV }} environment"
          
          # Check if Container App already exists
          if az containerapp show --name "${{ env.CONTAINER_APP_NAME }}-${{ steps.detect-env.outputs.NEW_ENV }}" --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" --query "name" -o tsv 2>/dev/null; then
            echo "Updating existing ${{ steps.detect-env.outputs.NEW_ENV }} Container App..."
            az containerapp update \
              --name "${{ env.CONTAINER_APP_NAME }}-${{ steps.detect-env.outputs.NEW_ENV }}" \
              --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
              --image "$FULL_IMAGE_NAME" \
              --set-env-vars ASPNETCORE_ENVIRONMENT=Production
          else
            echo "Creating new ${{ steps.detect-env.outputs.NEW_ENV }} Container App..."
            az containerapp create \
              --name "${{ env.CONTAINER_APP_NAME }}-${{ steps.detect-env.outputs.NEW_ENV }}" \
              --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
              --image "$FULL_IMAGE_NAME" \
              --environment "${{ env.CONTAINER_APP_ENVIRONMENT }}" \
              --target-port 8080 \
              --ingress external \
              --cpu 1.0 \
              --memory 2.0Gi \
              --min-replicas 2 \
              --max-replicas 5 \
              --env-vars ASPNETCORE_ENVIRONMENT=Production
          fi

      - name: Quick deployment verification
        run: |
          # Get the FQDN of the new deployment
          NEW_FQDN=$(az containerapp show \
            --name "${{ env.CONTAINER_APP_NAME }}-${{ steps.detect-env.outputs.NEW_ENV }}" \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --query "properties.configuration.ingress.fqdn" \
            --output tsv)
          
          echo " New deployment created: ${{ env.CONTAINER_APP_NAME }}-${{ steps.detect-env.outputs.NEW_ENV }}"
          echo " Public URL: https://$NEW_FQDN"
          
          # Quick check - wait 5 seconds then do ONE health check
          sleep 5
          
          # Single health check attempt with 10-second timeout
          echo "ðŸ” Performing quick health check..."
          if timeout 10 curl -s -f "https://$NEW_FQDN/health" > /dev/null; then
            echo " Health check passed!"
          else
            echo "  Quick health check failed or timed out"
            echo "Continuing anyway - Azure Container Apps will handle health probing"
          fi

      - name: Switch traffic in Azure Front Door
        run: |
          # Update Front Door to route 100% traffic to the new environment
          az network front-door routing-rule update \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --front-door-name "${{ env.FRONT_DOOR_NAME }}" \
            --name "bp-routing-rule" \
            --backend-pool "${{ steps.detect-env.outputs.NEW_BACKEND }}"
          
          echo " Traffic switched to ${{ steps.detect-env.outputs.NEW_ENV }} environment"

      - name: Verify traffic switch
        run: |
          # Get Front Door endpoint
          FD_ENDPOINT=$(az network front-door frontend-endpoint list \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --front-door-name "${{ env.FRONT_DOOR_NAME }}" \
            --query "[0].hostName" \
            --output tsv)
          
          echo " Front Door URL: https://$FD_ENDPOINT"
          
          # Quick verification that Front Door is responding
          sleep 5
          
          if timeout 10 curl -s -f "https://$FD_ENDPOINT/health" > /dev/null; then
            echo " Front Door is responding!"
          else
            echo "  Front Door health check failed or timed out"
            echo "This might be normal - DNS propagation can take a few minutes"
          fi

      - name: Clean up old environment
        run: |
          # Optionally, update the old environment with the new image for next deployment
          echo " Updating old environment (${{ steps.detect-env.outputs.CURRENT_ENV }}) for next deployment..."
          TAG="${{ needs.continuous-integration.outputs.docker-tag }}"
          FULL_IMAGE_NAME="${{ env.ACR_NAME }}.azurecr.io/bp-calculator:$TAG"
          
          az containerapp update \
            --name "${{ env.CONTAINER_APP_NAME }}-${{ steps.detect-env.outputs.CURRENT_ENV }}" \
            --resource-group "${{ env.AZURE_RESOURCE_GROUP }}" \
            --image "$FULL_IMAGE_NAME" \
            --set-env-vars ASPNETCORE_ENVIRONMENT=Production \
            --cpu 1.0 \
            --memory 2.0Gi \
            --min-replicas 1 \
            --max-replicas 2
          
          echo " Old environment updated and ready for next deployment cycle"
